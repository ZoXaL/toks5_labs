package com.zoxal.labs.toks.codes;

import java.math.BigInteger;
import java.util.Formatter;
import java.util.List;

/**
 * Вторая част 3 лабы по ТОКС.
 * Задача -- закодировать последовательность 10101101000101 CRC
 * кодированием с возможностью исправить одну либо обнаружит 2
 * ошибки.
 * <ol>
 *     <li>Находим подходящий полином</li>
 *     <li>Проверяем алгоритм исправления одной ошибки</li>
 *     <li>Проверяем алгоритм обнаружения двух ошибок</li>
 * </ol>
 * !! Здесь + означает xor
 *
 * @author Mike
 * @version 11/12/2017
 */
public class CRCPolynomCheck {
    public static void main(String[] args) {
        /*
        Для исправления одной и обнаружения двух ошибок кодовое расстояние должно быть
        не менее 4. Это накладывает на выбор полинома условия:
        1) в полиноме должно быть не менее 4 единиц (очевидно)
        2) разрядность полинома должна быть не менее k, полученного из
            k >= log2(k+m+1), где m -- число информационных символов
        Длина исходного слова 14. k = 5, откуда степень полинома 6 и разрядность кодового
        слова 20.
        3) Кроме этих условий есть ещё одно, которому должны соответствовать все циклические коды:
        сдвиг любого кодового слова порождает кодовое слово. Было S, стало
        либо
            x*S, если старший был 0
        либо
            x*S + (x^m+1), если старший был 1
        Для того, чтобы результат тоже гарантированно был кодовым словом (=делился на полином),
        нужно, чтобы x^m+1 делилось на полином. Это третье важное условие.
        4) При делении всех возможных векторов двойных ошибок полином должен дават остатки, содержащие
        не менее двух единиц в двоичной записи. Иначе отличить двойную ошибку от одиночной будет невозможно.
        Код ниже проверяет полиномы по этому пункту.


        x^20+1 = ((x^5+1)(x^5+1))((x^5+1)(x^5+1))
        Полином (x^5+1) не удовлетворяет указанным выше. Придется увеличить разрядность передаваемого слова.
        x^21+1 = (x + 1)(x^2 + x + 1)(x^3 + x + 1)(x^3 + x^2 + 1)(x^6 + x^4 + x^2 + x + 1)(x^6 + x^5 + x^4 + x^2 + 1)
        Тут есть относительно богатый выбор.
            Многочлены 6 степени не подходят по 4 пункту.
            Подходят (x + 1)(x^2 + x + 1)(x^3 + x + 1) и (x + 1)(x^2 + x + 1)(x^3 + x^2 + 1)
        В решении принят многочлен (x + 1)(x^2 + x + 1)(x^3 + x + 1), 1010011
         */

        // Подходящие по 4 пункту многочлены
        List<BigInteger> residues = CRCUtils.findPolynomes(20, 7);
        System.out.println(" === Available polynomes === ");
        CRCUtils.prettyPrintBIList(residues, 7);
        System.out.println(" =========================== ");

        // Исправление одной ошибки
        System.out.printf(
            "Добавляемый остаток: %06d\n",
            new BigInteger(
                CRCUtils.divide(
                    new BigInteger("010101101000101000000", 2),
                    new BigInteger("1010011", 2)
                ).toString(2)
            )
        );
        System.out.printf(
            "После добавления остатка: %06d\n",
            new BigInteger(
                CRCUtils.divide(
                    new BigInteger("010101101000101000111", 2),
                    new BigInteger("1010011", 2)
                ).toString(2)
            )
        );
        System.out.printf(
            "Остаток одиночной ошибки в 17 разряде: %06d\n",
            new BigInteger(
                CRCUtils.divide(
                    new BigInteger("010001101000101000111", 2),
                    new BigInteger("1010011", 2)
                ).toString(2)
            )
        );
        System.out.printf(
                "Остаток после первого сдвига влево: %06d\n",
                new BigInteger(
                        CRCUtils.divide(
                                new BigInteger("100011010001010001110", 2),
                                new BigInteger("1010011", 2)
                        ).toString(2)
                )
        );
        System.out.printf(
                "Остаток после второго сдвига влево: %06d\n",
                new BigInteger(
                        CRCUtils.divide(
                                new BigInteger("000110100010100011101", 2),
                                new BigInteger("1010011", 2)
                        ).toString(2)
                )
        );
        System.out.printf(
                "Остаток после третьего сдвига влево: %06d\n",
                new BigInteger(
                        CRCUtils.divide(
                                new BigInteger("001101000101000111010", 2),
                                new BigInteger("1010011", 2)
                        ).toString(2)
                )
        );
        System.out.printf(
                "Остаток после четвертого сдвига влево: %06d\n",
                new BigInteger(
                        CRCUtils.divide(
                                new BigInteger("011010001010001110100", 2),
                                new BigInteger("1010011", 2)
                        ).toString(2)
                )
        );
        System.out.println("--------------------");

        //Обнаружение двойной -- нет остатка с одной единицей
        List<BigInteger> res = CRCUtils.getCyclicResidues(
//              new BigInteger(    "010101101000101000111", 2),
                new BigInteger("010101101010101000011", 2),
                21,
                new BigInteger("1010011", 2)
        );
        CRCUtils.prettyPrintBIList(res, 6);
    }
}
